{"ast":null,"code":"/*\r\n Agent class.  An agent is a separate individual that communicates via messages to other agents.\r\n\r\n It contains a 3D representation implemented via three.js classes\r\n It contains a 2D parameter setup representation implemented via React components\r\n */\nexport class Agent {\n  constructor(context, id, world, size, x, y, z, rotx = 0, roty = 0, rotz = 0) {\n    console.log(\"base agent construct\");\n    this.THREE = context;\n    this.id = id;\n    this.size = size;\n    this.world = world;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.rotx = rotx;\n    this.roty = roty;\n    this.rotz = rotz;\n    this.state = {};\n    this.createMesh();\n    this.neighbors = [];\n  } // State should always be a single map for easier serialization\n\n\n  getState() {\n    return this.state;\n  }\n\n  getPosition() {\n    return new this.THREE.Vector3(this.x, this.y, this.z);\n  }\n\n  createMesh() {\n    this.geometry = new this.THREE.SphereGeometry(this.size, 24, 24, 0, Math.PI * 2, 0, Math.PI / 2);\n    this.material = new this.THREE.MeshBasicMaterial({\n      color: 0xFFFFFF\n    });\n    this.mesh = new this.THREE.Mesh(this.geometry, this.material);\n    this.mesh.position.copy(new this.THREE.Vector3(this.x, this.y, this.z));\n    this.mesh.rotation.x = this.rotx;\n    this.mesh.rotation.y = this.roty;\n    this.mesh.rotation.z = this.rotz;\n  } // Called only once.  You may modify it but cannot reallocate it.\n\n\n  getMesh() {\n    console.log(\"Mesh is: \" + this.mesh);\n    return this.mesh;\n  } // Simulation methods\n\n\n  loop() {}\n\n  addNeighbor(id) {\n    this.neighbors.push(id);\n  }\n\n  removeNeighbor(id) {\n    let index = this.neighbors.indexOf(id);\n    if (index != -1) this.neighbors.splice(index, 1);\n  }\n\n  receiveMessage(msg) {} // simulator.sendMessage(id,msg) - Sends a message to another Agent.  Has a variable delay\n\n\n}","map":{"version":3,"sources":["C:/cygwin64/home/giles/projs/personal/getalife/prototype/src/Agent.js"],"names":["Agent","constructor","context","id","world","size","x","y","z","rotx","roty","rotz","console","log","THREE","state","createMesh","neighbors","getState","getPosition","Vector3","geometry","SphereGeometry","Math","PI","material","MeshBasicMaterial","color","mesh","Mesh","position","copy","rotation","getMesh","loop","addNeighbor","push","removeNeighbor","index","indexOf","splice","receiveMessage","msg"],"mappings":"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","sourcesContent":["/*\r\n Agent class.  An agent is a separate individual that communicates via messages to other agents.\r\n\r\n It contains a 3D representation implemented via three.js classes\r\n It contains a 2D parameter setup representation implemented via React components\r\n */\r\nexport class Agent {\r\n  constructor(context,id,world,size,x,y,z,rotx=0,roty=0,rotz=0) {\r\n    console.log(\"base agent construct\");\r\n    this.THREE = context;\r\n    this.id = id;\r\n    this.size = size;\r\n    this.world = world;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n    this.rotx = rotx;\r\n    this.roty = roty;\r\n    this.rotz = rotz;\r\n    this.state = {};\r\n\r\n    this.createMesh();\r\n    this.neighbors = [];\r\n  }\r\n\r\n  // State should always be a single map for easier serialization\r\n  getState() {\r\n    return this.state;\r\n  }\r\n\r\n  getPosition() {\r\n    return new this.THREE.Vector3(this.x,this.y,this.z);\r\n  }\r\n\r\n  createMesh() {\r\n    this.geometry = new this.THREE.SphereGeometry(this.size, 24, 24,0,Math.PI*2,0,Math.PI/2);\r\n    this.material = new this.THREE.MeshBasicMaterial({\r\n      color: 0xFFFFFF,\r\n    });\r\n    this.mesh = new this.THREE.Mesh(this.geometry, this.material);\r\n    this.mesh.position.copy(new this.THREE.Vector3(this.x,this.y,this.z));\r\n    this.mesh.rotation.x = this.rotx;\r\n    this.mesh.rotation.y = this.roty;\r\n    this.mesh.rotation.z = this.rotz;\r\n  }\r\n\r\n  // Called only once.  You may modify it but cannot reallocate it.\r\n  getMesh() {\r\n    console.log(\"Mesh is: \" + this.mesh);\r\n    return this.mesh;\r\n  }\r\n\r\n  // Simulation methods\r\n  loop() {\r\n\r\n  }\r\n\r\n  addNeighbor(id) {\r\n    this.neighbors.push(id);\r\n  }\r\n\r\n  removeNeighbor(id) {\r\n    let index = this.neighbors.indexOf(id);\r\n    if (index != -1) this.neighbors.splice(index,1);\r\n  }\r\n\r\n  receiveMessage(msg) {\r\n\r\n  }\r\n\r\n  // simulator.sendMessage(id,msg) - Sends a message to another Agent.  Has a variable delay\r\n}\r\n"]},"metadata":{},"sourceType":"module"}