{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport * as tslib_1 from \"tslib\";\nimport { MDCFoundation } from '@material/base/foundation';\nimport { Corner, CornerBit, cssClasses, numbers, strings } from './constants';\n\nvar MDCMenuSurfaceFoundation =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MDCMenuSurfaceFoundation, _super);\n\n  function MDCMenuSurfaceFoundation(adapter) {\n    var _this = _super.call(this, tslib_1.__assign({}, MDCMenuSurfaceFoundation.defaultAdapter, adapter)) || this;\n\n    _this.isOpen_ = false;\n    _this.isQuickOpen_ = false;\n    _this.isHoistedElement_ = false;\n    _this.isFixedPosition_ = false;\n    _this.openAnimationEndTimerId_ = 0;\n    _this.closeAnimationEndTimerId_ = 0;\n    _this.animationRequestId_ = 0;\n    _this.anchorCorner_ = Corner.TOP_START;\n    _this.anchorMargin_ = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    _this.position_ = {\n      x: 0,\n      y: 0\n    };\n    return _this;\n  }\n\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"cssClasses\", {\n    get: function () {\n      return cssClasses;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"strings\", {\n    get: function () {\n      return strings;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"numbers\", {\n    get: function () {\n      return numbers;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"Corner\", {\n    get: function () {\n      return Corner;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MDCMenuSurfaceFoundation, \"defaultAdapter\", {\n    /**\n     * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.\n     */\n    get: function () {\n      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n      return {\n        addClass: function () {\n          return undefined;\n        },\n        removeClass: function () {\n          return undefined;\n        },\n        hasClass: function () {\n          return false;\n        },\n        hasAnchor: function () {\n          return false;\n        },\n        isElementInContainer: function () {\n          return false;\n        },\n        isFocused: function () {\n          return false;\n        },\n        isRtl: function () {\n          return false;\n        },\n        getInnerDimensions: function () {\n          return {\n            height: 0,\n            width: 0\n          };\n        },\n        getAnchorDimensions: function () {\n          return null;\n        },\n        getWindowDimensions: function () {\n          return {\n            height: 0,\n            width: 0\n          };\n        },\n        getBodyDimensions: function () {\n          return {\n            height: 0,\n            width: 0\n          };\n        },\n        getWindowScroll: function () {\n          return {\n            x: 0,\n            y: 0\n          };\n        },\n        setPosition: function () {\n          return undefined;\n        },\n        setMaxHeight: function () {\n          return undefined;\n        },\n        setTransformOrigin: function () {\n          return undefined;\n        },\n        saveFocus: function () {\n          return undefined;\n        },\n        restoreFocus: function () {\n          return undefined;\n        },\n        notifyClose: function () {\n          return undefined;\n        },\n        notifyOpen: function () {\n          return undefined;\n        }\n      }; // tslint:enable:object-literal-sort-keys\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MDCMenuSurfaceFoundation.prototype.init = function () {\n    var _a = MDCMenuSurfaceFoundation.cssClasses,\n        ROOT = _a.ROOT,\n        OPEN = _a.OPEN;\n\n    if (!this.adapter_.hasClass(ROOT)) {\n      throw new Error(ROOT + \" class required in root element.\");\n    }\n\n    if (this.adapter_.hasClass(OPEN)) {\n      this.isOpen_ = true;\n    }\n  };\n\n  MDCMenuSurfaceFoundation.prototype.destroy = function () {\n    clearTimeout(this.openAnimationEndTimerId_);\n    clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.\n\n    cancelAnimationFrame(this.animationRequestId_);\n  };\n  /**\n   * @param corner Default anchor corner alignment of top-left menu surface corner.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {\n    this.anchorCorner_ = corner;\n  };\n  /**\n   * @param margin Set of margin values from anchor.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {\n    this.anchorMargin_.top = margin.top || 0;\n    this.anchorMargin_.right = margin.right || 0;\n    this.anchorMargin_.bottom = margin.bottom || 0;\n    this.anchorMargin_.left = margin.left || 0;\n  };\n  /** Used to indicate if the menu-surface is hoisted to the body. */\n\n\n  MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {\n    this.isHoistedElement_ = isHoisted;\n  };\n  /** Used to set the menu-surface calculations based on a fixed position menu. */\n\n\n  MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {\n    this.isFixedPosition_ = isFixedPosition;\n  };\n  /** Sets the menu-surface position on the page. */\n\n\n  MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {\n    this.position_.x = this.isFinite_(x) ? x : 0;\n    this.position_.y = this.isFinite_(y) ? y : 0;\n  };\n\n  MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {\n    this.isQuickOpen_ = quickOpen;\n  };\n\n  MDCMenuSurfaceFoundation.prototype.isOpen = function () {\n    return this.isOpen_;\n  };\n  /**\n   * Open the menu surface.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.open = function () {\n    var _this = this;\n\n    this.adapter_.saveFocus();\n\n    if (!this.isQuickOpen_) {\n      this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n    }\n\n    this.animationRequestId_ = requestAnimationFrame(function () {\n      _this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n\n      _this.dimensions_ = _this.adapter_.getInnerDimensions();\n\n      _this.autoPosition_();\n\n      if (_this.isQuickOpen_) {\n        _this.adapter_.notifyOpen();\n      } else {\n        _this.openAnimationEndTimerId_ = setTimeout(function () {\n          _this.openAnimationEndTimerId_ = 0;\n\n          _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n\n          _this.adapter_.notifyOpen();\n        }, numbers.TRANSITION_OPEN_DURATION);\n      }\n    });\n    this.isOpen_ = true;\n  };\n  /**\n   * Closes the menu surface.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {\n    var _this = this;\n\n    if (skipRestoreFocus === void 0) {\n      skipRestoreFocus = false;\n    }\n\n    if (!this.isQuickOpen_) {\n      this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n    }\n\n    requestAnimationFrame(function () {\n      _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n\n      if (_this.isQuickOpen_) {\n        _this.adapter_.notifyClose();\n      } else {\n        _this.closeAnimationEndTimerId_ = setTimeout(function () {\n          _this.closeAnimationEndTimerId_ = 0;\n\n          _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n\n          _this.adapter_.notifyClose();\n        }, numbers.TRANSITION_CLOSE_DURATION);\n      }\n    });\n    this.isOpen_ = false;\n\n    if (!skipRestoreFocus) {\n      this.maybeRestoreFocus_();\n    }\n  };\n  /** Handle clicks and close if not within menu-surface element. */\n\n\n  MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {\n    var el = evt.target;\n\n    if (this.adapter_.isElementInContainer(el)) {\n      return;\n    }\n\n    this.close();\n  };\n  /** Handle keys that close the surface. */\n\n\n  MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {\n    var keyCode = evt.keyCode,\n        key = evt.key;\n    var isEscape = key === 'Escape' || keyCode === 27;\n\n    if (isEscape) {\n      this.close();\n    }\n  };\n\n  MDCMenuSurfaceFoundation.prototype.autoPosition_ = function () {\n    var _a; // Compute measurements for autoposition methods reuse.\n\n\n    this.measurements_ = this.getAutoLayoutMeasurements_();\n    var corner = this.getOriginCorner_();\n    var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);\n    var verticalAlignment = this.hasBit_(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\n    var horizontalAlignment = this.hasBit_(corner, CornerBit.RIGHT) ? 'right' : 'left';\n    var horizontalOffset = this.getHorizontalOriginOffset_(corner);\n    var verticalOffset = this.getVerticalOriginOffset_(corner);\n    var _b = this.measurements_,\n        anchorSize = _b.anchorSize,\n        surfaceSize = _b.surfaceSize;\n    var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, _a); // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.\n\n    if (anchorSize.width / surfaceSize.width > numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\n      horizontalAlignment = 'center';\n    } // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element\n\n\n    if (this.isHoistedElement_ || this.isFixedPosition_) {\n      this.adjustPositionForHoistedElement_(position);\n    }\n\n    this.adapter_.setTransformOrigin(horizontalAlignment + \" \" + verticalAlignment);\n    this.adapter_.setPosition(position);\n    this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');\n  };\n  /**\n   * @return Measurements used to position menu surface popup.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getAutoLayoutMeasurements_ = function () {\n    var anchorRect = this.adapter_.getAnchorDimensions();\n    var bodySize = this.adapter_.getBodyDimensions();\n    var viewportSize = this.adapter_.getWindowDimensions();\n    var windowScroll = this.adapter_.getWindowScroll();\n\n    if (!anchorRect) {\n      // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n      anchorRect = {\n        top: this.position_.y,\n        right: this.position_.x,\n        bottom: this.position_.y,\n        left: this.position_.x,\n        width: 0,\n        height: 0\n      }; // tslint:enable:object-literal-sort-keys\n    }\n\n    return {\n      anchorSize: anchorRect,\n      bodySize: bodySize,\n      surfaceSize: this.dimensions_,\n      viewportDistance: {\n        // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n        top: anchorRect.top,\n        right: viewportSize.width - anchorRect.right,\n        bottom: viewportSize.height - anchorRect.bottom,\n        left: anchorRect.left\n      },\n      viewportSize: viewportSize,\n      windowScroll: windowScroll\n    };\n  };\n  /**\n   * Computes the corner of the anchor from which to animate and position the menu surface.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getOriginCorner_ = function () {\n    // Defaults: open from the top left.\n    var corner = Corner.TOP_LEFT;\n    var _a = this.measurements_,\n        viewportDistance = _a.viewportDistance,\n        anchorSize = _a.anchorSize,\n        surfaceSize = _a.surfaceSize;\n    var isBottomAligned = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);\n    var availableTop = isBottomAligned ? viewportDistance.top + anchorSize.height + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;\n    var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorSize.height - this.anchorMargin_.top;\n    var topOverflow = surfaceSize.height - availableTop;\n    var bottomOverflow = surfaceSize.height - availableBottom;\n\n    if (bottomOverflow > 0 && topOverflow < bottomOverflow) {\n      corner = this.setBit_(corner, CornerBit.BOTTOM);\n    }\n\n    var isRtl = this.adapter_.isRtl();\n    var isFlipRtl = this.hasBit_(this.anchorCorner_, CornerBit.FLIP_RTL);\n    var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);\n    var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;\n    var availableLeft = isAlignedRight ? viewportDistance.left + anchorSize.width + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;\n    var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorSize.width - this.anchorMargin_.left;\n    var leftOverflow = surfaceSize.width - availableLeft;\n    var rightOverflow = surfaceSize.width - availableRight;\n\n    if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {\n      corner = this.setBit_(corner, CornerBit.RIGHT);\n    }\n\n    return corner;\n  };\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight_ = function (corner) {\n    var viewportDistance = this.measurements_.viewportDistance;\n    var maxHeight = 0;\n    var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);\n    var isBottomAnchored = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);\n    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE; // When maximum height is not specified, it is handled from CSS.\n\n    if (isBottomAligned) {\n      maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;\n\n      if (!isBottomAnchored) {\n        maxHeight += this.measurements_.anchorSize.height;\n      }\n    } else {\n      maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measurements_.anchorSize.height - MARGIN_TO_EDGE;\n\n      if (isBottomAnchored) {\n        maxHeight -= this.measurements_.anchorSize.height;\n      }\n    }\n\n    return maxHeight;\n  };\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset_ = function (corner) {\n    var anchorSize = this.measurements_.anchorSize; // isRightAligned corresponds to using the 'right' property on the surface.\n\n    var isRightAligned = this.hasBit_(corner, CornerBit.RIGHT);\n    var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);\n\n    if (isRightAligned) {\n      var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.left : this.anchorMargin_.right; // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so\n      // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,\n      // the right property is correct.\n\n      if (this.isHoistedElement_ || this.isFixedPosition_) {\n        return rightOffset - (this.measurements_.viewportSize.width - this.measurements_.bodySize.width);\n      }\n\n      return rightOffset;\n    }\n\n    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.right : this.anchorMargin_.left;\n  };\n  /**\n   * @param corner Origin corner of the menu surface.\n   * @return Vertical offset of menu surface origin corner from corresponding anchor corner.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset_ = function (corner) {\n    var anchorSize = this.measurements_.anchorSize;\n    var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);\n    var avoidVerticalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);\n    var y = 0;\n\n    if (isBottomAligned) {\n      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin_.top : -this.anchorMargin_.bottom;\n    } else {\n      y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin_.bottom : this.anchorMargin_.top;\n    }\n\n    return y;\n  };\n  /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */\n\n\n  MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement_ = function (position) {\n    var e_1, _a;\n\n    var _b = this.measurements_,\n        windowScroll = _b.windowScroll,\n        viewportDistance = _b.viewportDistance;\n    var props = Object.keys(position);\n\n    try {\n      for (var props_1 = tslib_1.__values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n        var prop = props_1_1.value;\n        var value = position[prop] || 0; // Hoisted surfaces need to have the anchor elements location on the page added to the\n        // position properties for proper alignment on the body.\n\n        value += viewportDistance[prop]; // Surfaces that are absolutely positioned need to have additional calculations for scroll\n        // and bottom positioning.\n\n        if (!this.isFixedPosition_) {\n          if (prop === 'top') {\n            value += windowScroll.y;\n          } else if (prop === 'bottom') {\n            value -= windowScroll.y;\n          } else if (prop === 'left') {\n            value += windowScroll.x;\n          } else {\n            // prop === 'right'\n            value -= windowScroll.x;\n          }\n        }\n\n        position[prop] = value;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n  /**\n   * The last focused element when the menu surface was opened should regain focus, if the user is\n   * focused on or within the menu surface when it is closed.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus_ = function () {\n    var isRootFocused = this.adapter_.isFocused();\n    var childHasFocus = document.activeElement && this.adapter_.isElementInContainer(document.activeElement);\n\n    if (isRootFocused || childHasFocus) {\n      this.adapter_.restoreFocus();\n    }\n  };\n\n  MDCMenuSurfaceFoundation.prototype.hasBit_ = function (corner, bit) {\n    return Boolean(corner & bit); // tslint:disable-line:no-bitwise\n  };\n\n  MDCMenuSurfaceFoundation.prototype.setBit_ = function (corner, bit) {\n    return corner | bit; // tslint:disable-line:no-bitwise\n  };\n  /**\n   * isFinite that doesn't force conversion to number type.\n   * Equivalent to Number.isFinite in ES2015, which is not supported in IE.\n   */\n\n\n  MDCMenuSurfaceFoundation.prototype.isFinite_ = function (num) {\n    return typeof num === 'number' && isFinite(num);\n  };\n\n  return MDCMenuSurfaceFoundation;\n}(MDCFoundation);\n\nexport { MDCMenuSurfaceFoundation }; // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\n\nexport default MDCMenuSurfaceFoundation;","map":{"version":3,"sources":["foundation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nimport * as tslib_1 from \"tslib\";\nimport { MDCFoundation } from '@material/base/foundation';\nimport { Corner, CornerBit, cssClasses, numbers, strings } from './constants';\nvar MDCMenuSurfaceFoundation = /** @class */ (function (_super) {\n    tslib_1.__extends(MDCMenuSurfaceFoundation, _super);\n    function MDCMenuSurfaceFoundation(adapter) {\n        var _this = _super.call(this, tslib_1.__assign({}, MDCMenuSurfaceFoundation.defaultAdapter, adapter)) || this;\n        _this.isOpen_ = false;\n        _this.isQuickOpen_ = false;\n        _this.isHoistedElement_ = false;\n        _this.isFixedPosition_ = false;\n        _this.openAnimationEndTimerId_ = 0;\n        _this.closeAnimationEndTimerId_ = 0;\n        _this.animationRequestId_ = 0;\n        _this.anchorCorner_ = Corner.TOP_START;\n        _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };\n        _this.position_ = { x: 0, y: 0 };\n        return _this;\n    }\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"cssClasses\", {\n        get: function () {\n            return cssClasses;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"strings\", {\n        get: function () {\n            return strings;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"numbers\", {\n        get: function () {\n            return numbers;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"Corner\", {\n        get: function () {\n            return Corner;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MDCMenuSurfaceFoundation, \"defaultAdapter\", {\n        /**\n         * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.\n         */\n        get: function () {\n            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.\n            return {\n                addClass: function () { return undefined; },\n                removeClass: function () { return undefined; },\n                hasClass: function () { return false; },\n                hasAnchor: function () { return false; },\n                isElementInContainer: function () { return false; },\n                isFocused: function () { return false; },\n                isRtl: function () { return false; },\n                getInnerDimensions: function () { return ({ height: 0, width: 0 }); },\n                getAnchorDimensions: function () { return null; },\n                getWindowDimensions: function () { return ({ height: 0, width: 0 }); },\n                getBodyDimensions: function () { return ({ height: 0, width: 0 }); },\n                getWindowScroll: function () { return ({ x: 0, y: 0 }); },\n                setPosition: function () { return undefined; },\n                setMaxHeight: function () { return undefined; },\n                setTransformOrigin: function () { return undefined; },\n                saveFocus: function () { return undefined; },\n                restoreFocus: function () { return undefined; },\n                notifyClose: function () { return undefined; },\n                notifyOpen: function () { return undefined; },\n            };\n            // tslint:enable:object-literal-sort-keys\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MDCMenuSurfaceFoundation.prototype.init = function () {\n        var _a = MDCMenuSurfaceFoundation.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;\n        if (!this.adapter_.hasClass(ROOT)) {\n            throw new Error(ROOT + \" class required in root element.\");\n        }\n        if (this.adapter_.hasClass(OPEN)) {\n            this.isOpen_ = true;\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.destroy = function () {\n        clearTimeout(this.openAnimationEndTimerId_);\n        clearTimeout(this.closeAnimationEndTimerId_);\n        // Cancel any currently running animations.\n        cancelAnimationFrame(this.animationRequestId_);\n    };\n    /**\n     * @param corner Default anchor corner alignment of top-left menu surface corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {\n        this.anchorCorner_ = corner;\n    };\n    /**\n     * @param margin Set of margin values from anchor.\n     */\n    MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {\n        this.anchorMargin_.top = margin.top || 0;\n        this.anchorMargin_.right = margin.right || 0;\n        this.anchorMargin_.bottom = margin.bottom || 0;\n        this.anchorMargin_.left = margin.left || 0;\n    };\n    /** Used to indicate if the menu-surface is hoisted to the body. */\n    MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {\n        this.isHoistedElement_ = isHoisted;\n    };\n    /** Used to set the menu-surface calculations based on a fixed position menu. */\n    MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {\n        this.isFixedPosition_ = isFixedPosition;\n    };\n    /** Sets the menu-surface position on the page. */\n    MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {\n        this.position_.x = this.isFinite_(x) ? x : 0;\n        this.position_.y = this.isFinite_(y) ? y : 0;\n    };\n    MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {\n        this.isQuickOpen_ = quickOpen;\n    };\n    MDCMenuSurfaceFoundation.prototype.isOpen = function () {\n        return this.isOpen_;\n    };\n    /**\n     * Open the menu surface.\n     */\n    MDCMenuSurfaceFoundation.prototype.open = function () {\n        var _this = this;\n        this.adapter_.saveFocus();\n        if (!this.isQuickOpen_) {\n            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n        }\n        this.animationRequestId_ = requestAnimationFrame(function () {\n            _this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n            _this.dimensions_ = _this.adapter_.getInnerDimensions();\n            _this.autoPosition_();\n            if (_this.isQuickOpen_) {\n                _this.adapter_.notifyOpen();\n            }\n            else {\n                _this.openAnimationEndTimerId_ = setTimeout(function () {\n                    _this.openAnimationEndTimerId_ = 0;\n                    _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);\n                    _this.adapter_.notifyOpen();\n                }, numbers.TRANSITION_OPEN_DURATION);\n            }\n        });\n        this.isOpen_ = true;\n    };\n    /**\n     * Closes the menu surface.\n     */\n    MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {\n        var _this = this;\n        if (skipRestoreFocus === void 0) { skipRestoreFocus = false; }\n        if (!this.isQuickOpen_) {\n            this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n        }\n        requestAnimationFrame(function () {\n            _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);\n            if (_this.isQuickOpen_) {\n                _this.adapter_.notifyClose();\n            }\n            else {\n                _this.closeAnimationEndTimerId_ = setTimeout(function () {\n                    _this.closeAnimationEndTimerId_ = 0;\n                    _this.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);\n                    _this.adapter_.notifyClose();\n                }, numbers.TRANSITION_CLOSE_DURATION);\n            }\n        });\n        this.isOpen_ = false;\n        if (!skipRestoreFocus) {\n            this.maybeRestoreFocus_();\n        }\n    };\n    /** Handle clicks and close if not within menu-surface element. */\n    MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {\n        var el = evt.target;\n        if (this.adapter_.isElementInContainer(el)) {\n            return;\n        }\n        this.close();\n    };\n    /** Handle keys that close the surface. */\n    MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {\n        var keyCode = evt.keyCode, key = evt.key;\n        var isEscape = key === 'Escape' || keyCode === 27;\n        if (isEscape) {\n            this.close();\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.autoPosition_ = function () {\n        var _a;\n        // Compute measurements for autoposition methods reuse.\n        this.measurements_ = this.getAutoLayoutMeasurements_();\n        var corner = this.getOriginCorner_();\n        var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);\n        var verticalAlignment = this.hasBit_(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';\n        var horizontalAlignment = this.hasBit_(corner, CornerBit.RIGHT) ? 'right' : 'left';\n        var horizontalOffset = this.getHorizontalOriginOffset_(corner);\n        var verticalOffset = this.getVerticalOriginOffset_(corner);\n        var _b = this.measurements_, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;\n        var position = (_a = {},\n            _a[horizontalAlignment] = horizontalOffset,\n            _a[verticalAlignment] = verticalOffset,\n            _a);\n        // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.\n        if (anchorSize.width / surfaceSize.width > numbers.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {\n            horizontalAlignment = 'center';\n        }\n        // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element\n        if (this.isHoistedElement_ || this.isFixedPosition_) {\n            this.adjustPositionForHoistedElement_(position);\n        }\n        this.adapter_.setTransformOrigin(horizontalAlignment + \" \" + verticalAlignment);\n        this.adapter_.setPosition(position);\n        this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');\n    };\n    /**\n     * @return Measurements used to position menu surface popup.\n     */\n    MDCMenuSurfaceFoundation.prototype.getAutoLayoutMeasurements_ = function () {\n        var anchorRect = this.adapter_.getAnchorDimensions();\n        var bodySize = this.adapter_.getBodyDimensions();\n        var viewportSize = this.adapter_.getWindowDimensions();\n        var windowScroll = this.adapter_.getWindowScroll();\n        if (!anchorRect) {\n            // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n            anchorRect = {\n                top: this.position_.y,\n                right: this.position_.x,\n                bottom: this.position_.y,\n                left: this.position_.x,\n                width: 0,\n                height: 0,\n            };\n            // tslint:enable:object-literal-sort-keys\n        }\n        return {\n            anchorSize: anchorRect,\n            bodySize: bodySize,\n            surfaceSize: this.dimensions_,\n            viewportDistance: {\n                // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together\n                top: anchorRect.top,\n                right: viewportSize.width - anchorRect.right,\n                bottom: viewportSize.height - anchorRect.bottom,\n                left: anchorRect.left,\n            },\n            viewportSize: viewportSize,\n            windowScroll: windowScroll,\n        };\n    };\n    /**\n     * Computes the corner of the anchor from which to animate and position the menu surface.\n     */\n    MDCMenuSurfaceFoundation.prototype.getOriginCorner_ = function () {\n        // Defaults: open from the top left.\n        var corner = Corner.TOP_LEFT;\n        var _a = this.measurements_, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;\n        var isBottomAligned = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);\n        var availableTop = isBottomAligned ? viewportDistance.top + anchorSize.height + this.anchorMargin_.bottom\n            : viewportDistance.top + this.anchorMargin_.top;\n        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom\n            : viewportDistance.bottom + anchorSize.height - this.anchorMargin_.top;\n        var topOverflow = surfaceSize.height - availableTop;\n        var bottomOverflow = surfaceSize.height - availableBottom;\n        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {\n            corner = this.setBit_(corner, CornerBit.BOTTOM);\n        }\n        var isRtl = this.adapter_.isRtl();\n        var isFlipRtl = this.hasBit_(this.anchorCorner_, CornerBit.FLIP_RTL);\n        var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);\n        var isAlignedRight = (avoidHorizontalOverlap && !isRtl) ||\n            (!avoidHorizontalOverlap && isFlipRtl && isRtl);\n        var availableLeft = isAlignedRight ? viewportDistance.left + anchorSize.width + this.anchorMargin_.right :\n            viewportDistance.left + this.anchorMargin_.left;\n        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right :\n            viewportDistance.right + anchorSize.width - this.anchorMargin_.left;\n        var leftOverflow = surfaceSize.width - availableLeft;\n        var rightOverflow = surfaceSize.width - availableRight;\n        if ((leftOverflow < 0 && isAlignedRight && isRtl) ||\n            (avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0) ||\n            (rightOverflow > 0 && leftOverflow < rightOverflow)) {\n            corner = this.setBit_(corner, CornerBit.RIGHT);\n        }\n        return corner;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Maximum height of the menu surface, based on available space. 0 indicates should not be set.\n     */\n    MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight_ = function (corner) {\n        var viewportDistance = this.measurements_.viewportDistance;\n        var maxHeight = 0;\n        var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);\n        var isBottomAnchored = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);\n        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;\n        // When maximum height is not specified, it is handled from CSS.\n        if (isBottomAligned) {\n            maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;\n            if (!isBottomAnchored) {\n                maxHeight += this.measurements_.anchorSize.height;\n            }\n        }\n        else {\n            maxHeight =\n                viewportDistance.bottom - this.anchorMargin_.bottom + this.measurements_.anchorSize.height - MARGIN_TO_EDGE;\n            if (isBottomAnchored) {\n                maxHeight -= this.measurements_.anchorSize.height;\n            }\n        }\n        return maxHeight;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Horizontal offset of menu surface origin corner from corresponding anchor corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset_ = function (corner) {\n        var anchorSize = this.measurements_.anchorSize;\n        // isRightAligned corresponds to using the 'right' property on the surface.\n        var isRightAligned = this.hasBit_(corner, CornerBit.RIGHT);\n        var avoidHorizontalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.RIGHT);\n        if (isRightAligned) {\n            var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.left : this.anchorMargin_.right;\n            // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so\n            // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,\n            // the right property is correct.\n            if (this.isHoistedElement_ || this.isFixedPosition_) {\n                return rightOffset - (this.measurements_.viewportSize.width - this.measurements_.bodySize.width);\n            }\n            return rightOffset;\n        }\n        return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin_.right : this.anchorMargin_.left;\n    };\n    /**\n     * @param corner Origin corner of the menu surface.\n     * @return Vertical offset of menu surface origin corner from corresponding anchor corner.\n     */\n    MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset_ = function (corner) {\n        var anchorSize = this.measurements_.anchorSize;\n        var isBottomAligned = this.hasBit_(corner, CornerBit.BOTTOM);\n        var avoidVerticalOverlap = this.hasBit_(this.anchorCorner_, CornerBit.BOTTOM);\n        var y = 0;\n        if (isBottomAligned) {\n            y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin_.top : -this.anchorMargin_.bottom;\n        }\n        else {\n            y = avoidVerticalOverlap ? (anchorSize.height + this.anchorMargin_.bottom) : this.anchorMargin_.top;\n        }\n        return y;\n    };\n    /** Calculates the offsets for positioning the menu-surface when the menu-surface has been hoisted to the body. */\n    MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement_ = function (position) {\n        var e_1, _a;\n        var _b = this.measurements_, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance;\n        var props = Object.keys(position);\n        try {\n            for (var props_1 = tslib_1.__values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {\n                var prop = props_1_1.value;\n                var value = position[prop] || 0;\n                // Hoisted surfaces need to have the anchor elements location on the page added to the\n                // position properties for proper alignment on the body.\n                value += viewportDistance[prop];\n                // Surfaces that are absolutely positioned need to have additional calculations for scroll\n                // and bottom positioning.\n                if (!this.isFixedPosition_) {\n                    if (prop === 'top') {\n                        value += windowScroll.y;\n                    }\n                    else if (prop === 'bottom') {\n                        value -= windowScroll.y;\n                    }\n                    else if (prop === 'left') {\n                        value += windowScroll.x;\n                    }\n                    else { // prop === 'right'\n                        value -= windowScroll.x;\n                    }\n                }\n                position[prop] = value;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    /**\n     * The last focused element when the menu surface was opened should regain focus, if the user is\n     * focused on or within the menu surface when it is closed.\n     */\n    MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus_ = function () {\n        var isRootFocused = this.adapter_.isFocused();\n        var childHasFocus = document.activeElement && this.adapter_.isElementInContainer(document.activeElement);\n        if (isRootFocused || childHasFocus) {\n            this.adapter_.restoreFocus();\n        }\n    };\n    MDCMenuSurfaceFoundation.prototype.hasBit_ = function (corner, bit) {\n        return Boolean(corner & bit); // tslint:disable-line:no-bitwise\n    };\n    MDCMenuSurfaceFoundation.prototype.setBit_ = function (corner, bit) {\n        return corner | bit; // tslint:disable-line:no-bitwise\n    };\n    /**\n     * isFinite that doesn't force conversion to number type.\n     * Equivalent to Number.isFinite in ES2015, which is not supported in IE.\n     */\n    MDCMenuSurfaceFoundation.prototype.isFinite_ = function (num) {\n        return typeof num === 'number' && isFinite(num);\n    };\n    return MDCMenuSurfaceFoundation;\n}(MDCFoundation));\nexport { MDCMenuSurfaceFoundation };\n// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.\nexport default MDCMenuSurfaceFoundation;\n//# sourceMappingURL=foundation.js.map"]},"metadata":{},"sourceType":"module"}